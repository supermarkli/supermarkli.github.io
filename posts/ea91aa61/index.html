<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/video-game.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/video-game.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/video-game.ico">
  <link rel="mask-icon" href="/images/video-game.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"supermarkli.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"agate","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"show_result":true,"style":"default"},"fold":{"enable":false,"height":500}},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="想快速看懂“上电到操作系统启动”这段黑屏时间到底发生了什么？">
<meta property="og:type" content="article">
<meta property="og:title" content="BIOS">
<meta property="og:url" content="https://supermarkli.github.io/posts/ea91aa61/index.html">
<meta property="og:site_name" content="吃糠咽菜">
<meta property="og:description" content="想快速看懂“上电到操作系统启动”这段黑屏时间到底发生了什么？">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-11-19T09:09:15.000Z">
<meta property="article:modified_time" content="2025-11-25T03:51:04.147Z">
<meta property="article:author" content="吃糠咽菜">
<meta property="article:tag" content="note,coding,life">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://supermarkli.github.io/posts/ea91aa61/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://supermarkli.github.io/posts/ea91aa61/","path":"posts/ea91aa61/","title":"BIOS"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>BIOS | 吃糠咽菜</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.7.0/mermaid.min.js","integrity":"sha256-4+IKDqhZ/sXjc8Wtl2/MsxI4e0s1KpEVdbEP7V/Lz8U="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>



  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","mhchem":false,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="吃糠咽菜" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">吃糠咽菜</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好记性不如烂笔头</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E9%80%9F%E8%AF%BB"><span class="nav-number">1.</span> <span class="nav-text">📚 基本概念速读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E4%B8%8B%E7%94%B5%E6%BA%90%E9%94%AE%E7%9A%84%E9%80%90%E5%B8%A7%E8%A7%A3%E8%AF%B4"><span class="nav-number">2.</span> <span class="nav-text">⚡ 按下电源键的逐帧解说</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bios-%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">3.</span> <span class="nav-text">🧠 BIOS 在哪里？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bios-%E7%9A%84%E5%9B%9B%E5%A4%A7%E8%81%8C%E8%B4%A3"><span class="nav-number">4.</span> <span class="nav-text">🧱 BIOS 的四大职责</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#post"><span class="nav-number">4.1.</span> <span class="nav-text">🔍 POST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.2.</span> <span class="nav-text">🛠️ 硬件初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="nav-number">4.3.</span> <span class="nav-text">建立中断向量表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD"><span class="nav-number">4.4.</span> <span class="nav-text">🚀 引导加载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bios-%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.</span> <span class="nav-text">🔌 BIOS 中断服务详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8-ivt"><span class="nav-number">5.1.</span> <span class="nav-text">💡 深入理解：中断向量表 (IVT)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">🔄 中断调用过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F"><span class="nav-number">5.3.</span> <span class="nav-text">📋 常见中断向量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.4.</span> <span class="nav-text">💻 自定义中断向量示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.5.</span> <span class="nav-text">⚠️ 重要注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8-bios-%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E8%AF%A6%E8%A7%A3"><span class="nav-number">6.</span> <span class="nav-text">📺 常用 BIOS 中断服务详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#int-0x10---%E8%A7%86%E9%A2%91%E6%9C%8D%E5%8A%A1"><span class="nav-number">6.1.</span> <span class="nav-text">INT 0x10 - 视频服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-0x13---%E7%A3%81%E7%9B%98%E6%9C%8D%E5%8A%A1"><span class="nav-number">6.2.</span> <span class="nav-text">INT 0x13 - 磁盘服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#chs-%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.3.</span> <span class="nav-text">CHS 寻址模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-0x16---%E9%94%AE%E7%9B%98%E6%9C%8D%E5%8A%A1"><span class="nav-number">6.4.</span> <span class="nav-text">INT 0x16 - 键盘服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-0x15---%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="nav-number">6.5.</span> <span class="nav-text">INT 0x15 - 系统服务</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="吃糠咽菜"
      src="/images/csnr.jpg">
  <p class="site-author-name" itemprop="name">吃糠咽菜</p>
  <div class="site-description" itemprop="description">一些乱七八糟的笔记</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">88</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/supermarkli" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;supermarkli" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:12110504@mail.sustech.edu.cn" title="E-Mail → mailto:12110504@mail.sustech.edu.cn" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://supermarkli.github.io/posts/ea91aa61/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/csnr.jpg">
      <meta itemprop="name" content="吃糠咽菜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吃糠咽菜">
      <meta itemprop="description" content="一些乱七八糟的笔记">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="BIOS | 吃糠咽菜">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          BIOS
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-11-19 17:09:15" itemprop="dateCreated datePublished" datetime="2025-11-19T17:09:15+08:00">2025-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-25 11:51:04" itemprop="dateModified" datetime="2025-11-25T11:51:04+08:00">2025-11-25</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>想快速看懂“上电到操作系统启动”这段黑屏时间到底发生了什么？</p>
<span id="more"></span>
<h3 id="基本概念速读">📚 基本概念速读</h3>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>定义</th>
<th>省流</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BIOS</td>
<td>Basic Input/Output System，主板固化固件，负责最初的硬件初始化与引导。</td>
<td>启动第一棒</td>
</tr>
<tr class="even">
<td>UEFI</td>
<td>现代固件接口，取代传统 16bit BIOS；但业内仍习惯统称"BIOS"。</td>
<td>BIOS 2.0</td>
</tr>
<tr class="odd">
<td>POST</td>
<td>Power-On Self-Test，BIOS 执行的自检流程，点亮蜂鸣器/Debug LED。</td>
<td>自体检</td>
</tr>
<tr class="even">
<td>Boot Device</td>
<td>BIOS 搜索可启动介质（SSD/U 盘/网卡）的目标。</td>
<td>“从哪儿启动”</td>
</tr>
<tr class="odd">
<td>CMOS</td>
<td>Complementary Metal-Oxide-Semiconductor，存储 BIOS 设置的小容量存储器，断电时靠纽扣电池供电。</td>
<td>设置仓库</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>UEFI vs 传统 BIOS 简要对比：</strong></p>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>传统 BIOS</th>
<th>UEFI</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>启动方式</strong></td>
<td>从固定地址 <code>0xFFFFFFF0</code> 启动，16位实模式</td>
<td>从 EFI 系统分区（ESP）启动，支持 32/64 位</td>
</tr>
<tr class="even">
<td><strong>分区表</strong></td>
<td>主要使用 MBR（主引导记录）</td>
<td>主要使用 GPT（GUID 分区表）</td>
</tr>
<tr class="odd">
<td><strong>磁盘容量限制</strong></td>
<td>MBR 限制 2TB</td>
<td>GPT 支持 9.4 ZB（zettabytes）</td>
</tr>
<tr class="even">
<td><strong>启动速度</strong></td>
<td>较慢（需要 POST 自检）</td>
<td>较快（并行初始化，跳过部分自检）</td>
</tr>
<tr class="odd">
<td><strong>图形界面</strong></td>
<td>文本界面</td>
<td>支持图形界面和鼠标操作</td>
</tr>
<tr class="even">
<td><strong>安全启动</strong></td>
<td>不支持</td>
<td>支持 Secure Boot（安全启动）</td>
</tr>
<tr class="odd">
<td><strong>网络启动</strong></td>
<td>需要 Option ROM</td>
<td>原生支持 PXE 网络启动</td>
</tr>
<tr class="even">
<td><strong>编程语言</strong></td>
<td>汇编语言为主</td>
<td>主要使用 C 语言</td>
</tr>
<tr class="odd">
<td><strong>兼容性</strong></td>
<td>仅支持 x86/x64</td>
<td>支持 x86、x64、ARM 等多种架构</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：本文主要介绍<strong>传统 BIOS</strong>的工作原理，这是理解现代 UEFI 的基础。UEFI 在底层仍然兼容传统 BIOS 的某些机制（如 Legacy Boot 模式）。</p>
</blockquote>
<h3 id="按下电源键的逐帧解说">⚡ 按下电源键的逐帧解说</h3>
<ol type="1">
<li><strong>硬件上电阶段（Power-On）</strong>
<ul>
<li>主板供电，所有核心电压被拉起。<br />
</li>
<li>CPU 复位后被强制从物理地址 <code>0xFFFFFFF0</code> 取第一条指令（实模式下无虚拟地址转换）。<br />
</li>
<li>该地址由芯片组映射到 BIOS ROM，因此固件立即接管执行。</li>
</ul></li>
<li><strong>POST 自检阶段（Power-On Self Test）</strong>
<ul>
<li>检测 CPU 是否正常。<br />
</li>
<li>检测内存大小和完整性。<br />
</li>
<li>检测显卡、键盘等基本设备。<br />
</li>
<li>若一切正常，蜂鸣器发出“嘀”的提示音。</li>
</ul></li>
<li><strong>BIOS 初始化阶段</strong>
<ul>
<li>初始化中断向量表（IVT）。<br />
</li>
<li>初始化显卡、磁盘控制器等硬件。<br />
</li>
<li>提供 BIOS 中断服务（INT 0x10、0x13 等）。<br />
</li>
<li>读取 CMOS，获取启动设备顺序。</li>
</ul></li>
<li><strong>寻找引导设备</strong>
<ul>
<li>按顺序尝试设备（硬盘 → 光驱 → USB 等）。<br />
</li>
<li>读取每个设备的第一个扇区（512 字节）。<br />
</li>
<li>检查扇区末尾是否为 <code>0x55AA</code> 引导标志，确认后继续加载。</li>
</ul></li>
<li><strong>加载 MBR 到内存</strong>
<ul>
<li>将引导扇区加载到物理地址 <code>0x7C00</code>。<br />
</li>
<li>设置 <code>CS:IP = 0x0000:0x7C00</code>。<br />
</li>
<li>跳转执行（CPU 控制权交给引导程序）。</li>
</ul></li>
<li><strong>引导程序执行（Stage 1 / Stage 2）</strong>
<ul>
<li>Stage 1：运行 MBR 引导扇区（512 字节）。<br />
</li>
<li>Stage 2：加载扩展引导加载器（负责加载内核等）。<br />
</li>
<li>切换到保护模式（16 位 → 32 位）。</li>
</ul></li>
<li><strong>内核接管系统</strong>
<ul>
<li>完成内核初始化。<br />
</li>
<li>设置中断描述符表（IDT）。<br />
</li>
<li>初始化内存管理。<br />
</li>
<li>启动第一个进程。</li>
</ul></li>
</ol>
<h3 id="bios-在哪里">🧠 BIOS 在哪里？</h3>
<ul>
<li>固化在主板上的 EEPROM / SPI Flash 芯片里。</li>
<li>地址通常映射到物理内存高端（如 <code>0xF0000-0xFFFFF</code> 区域）。</li>
<li>不依赖操作系统，通电后即可独立工作。</li>
</ul>
<p><strong>物理地址空间分布（32位系统）：</strong></p>
<table>
<thead>
<tr class="header">
<th>地址范围</th>
<th>映射内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0x00000000 - 0x0009FFFF</code></td>
<td>常规 RAM</td>
<td>640KB 传统内存（<strong><code>0x00000-0x003FF</code> 为 IVT，占用前 1KB</strong>）</td>
</tr>
<tr class="even">
<td><code>0x000A0000 - 0x000BFFFF</code></td>
<td>视频 RAM (VRAM)</td>
<td>显卡显存映射</td>
</tr>
<tr class="odd">
<td><code>0x000C0000 - 0x000DFFFF</code></td>
<td>扩展 ROM</td>
<td>网卡/RAID 卡 Option ROM</td>
</tr>
<tr class="even">
<td><code>0x000E0000 - 0x000EFFFF</code></td>
<td>保留区域</td>
<td>未使用</td>
</tr>
<tr class="odd">
<td><code>0x000F0000 - 0x000FFFFF</code></td>
<td>BIOS ROM (低端)</td>
<td>传统 BIOS 代码区</td>
</tr>
<tr class="even">
<td><code>0x00100000 - 0x3FFFFFFF</code></td>
<td>扩展 RAM</td>
<td>1MB 以上常规内存</td>
</tr>
<tr class="odd">
<td><code>0xFFF00000 - 0xFFFFFFFF</code></td>
<td>BIOS ROM (高端)</td>
<td><strong><code>0xFFFFFFF0</code> 位于此区域</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>64位系统的地址映射：</strong></p>
<ul>
<li>64位系统（x86-64）在启动时仍然使用<strong>兼容模式</strong>，地址映射与32位系统基本相同。</li>
<li>CPU 上电后从 <code>0xFFFFFFF0</code> 启动（仍然是32位地址空间的高端）。</li>
<li>在进入64位长模式（Long Mode）之前，系统仍然使用32位地址空间布局。</li>
<li><strong>主要区别</strong>：
<ul>
<li>64位模式下，物理地址空间可以扩展到 2⁴⁸ 或 2⁵² 字节（取决于 CPU 支持）。</li>
<li>但 BIOS ROM 的映射位置（<code>0xF0000-0xFFFFF</code> 和 <code>0xFFF00000-0xFFFFFFFF</code>）保持不变，以确保向后兼容。</li>
<li>现代 UEFI 系统可能使用不同的映射方式，但传统 BIOS 模式仍然遵循上述布局。</li>
</ul></li>
</ul>
</blockquote>
<p><strong>为什么 BIOS 分低端和高端？</strong></p>
<p>这是 x86 架构的历史兼容性与现代启动机制共同作用的结果：</p>
<ol type="1">
<li><strong>历史原因（低端映射 <code>0xF0000-0xFFFFF</code>）</strong>
<ul>
<li>在早期的 IBM PC（1981年）中，BIOS ROM 被映射到 <code>0xF0000-0xFFFFF</code>（位于 1MB 地址空间内）。</li>
<li>实模式下，BIOS 中断服务（如 INT 0x10、INT 0x13）的代码位于该区域。</li>
<li>为了保持向后兼容，现代系统仍保留该映射。</li>
</ul></li>
<li><strong>现代启动机制（高端映射 <code>0xFFF00000-0xFFFFFFFF</code>）</strong>
<ul>
<li>在 32 位系统中，CPU 上电后从 <code>0xFFFFFFF0</code> 取第一条指令。</li>
<li>该地址位于 32 位地址空间的高端（接近 4GB 边界）。</li>
<li>芯片组将 <code>0xFFFFFFF0</code> 映射到同一块 BIOS ROM 芯片，确保上电后能立即执行 BIOS 代码。</li>
</ul></li>
<li><strong>为什么需要两个映射？</strong>
<ul>
<li><strong>低端映射</strong>：用于兼容实模式下的 BIOS 中断调用和旧代码。</li>
<li><strong>高端映射</strong>：满足 CPU 上电后从 <code>0xFFFFFFF0</code> 启动的要求。</li>
</ul></li>
<li><strong>实际物理位置</strong>
<ul>
<li>两个地址映射到<strong>同一块</strong>主板上的 BIOS ROM 芯片（SPI Flash/EEPROM）。</li>
<li>芯片组通过内存映射 I/O（MMIO）将这两个地址都指向同一物理芯片，实现"一个 ROM，两个地址窗口"。</li>
</ul></li>
</ol>
<p><strong><code>0xFFFFFFF0</code> 访问的是什么？</strong></p>
<ul>
<li>这是<strong>内存映射 I/O（MMIO）地址</strong>，由<strong>芯片组（北桥/南桥）</strong>将 CPU 的物理地址请求映射到主板上的 <strong>BIOS ROM 芯片</strong>。</li>
<li>CPU 访问 <code>0xFFFFFFF0</code> 时，芯片组会拦截这个地址，转而从 SPI Flash/EEPROM 芯片中读取数据。</li>
<li>这种映射在硬件层面完成，无需软件参与，确保 CPU 上电后能立即执行 BIOS 代码。</li>
</ul>
<p><strong>ROM 是内存吗？与硬盘存储有什么区别？</strong></p>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>ROM（只读存储器）</th>
<th>RAM（随机存取存储器）</th>
<th>硬盘存储（HDD/SSD）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>是否属于内存</strong></td>
<td>✅ 是（非易失性内存）</td>
<td>✅ 是（易失性内存）</td>
<td>❌ 不是（外存/存储设备）</td>
</tr>
<tr class="even">
<td><strong>断电后数据</strong></td>
<td>保留</td>
<td>丢失</td>
<td>保留</td>
</tr>
<tr class="odd">
<td><strong>访问速度</strong></td>
<td>较慢（纳秒级）</td>
<td>很快（纳秒级）</td>
<td>很慢（微秒/毫秒级）</td>
</tr>
<tr class="even">
<td><strong>可写性</strong></td>
<td>只读（或需特殊方式写入）</td>
<td>可读写</td>
<td>可读写</td>
</tr>
<tr class="odd">
<td><strong>容量</strong></td>
<td>小（几MB到几十MB）</td>
<td>中等（几GB到几十GB）</td>
<td>大（几百GB到几TB）</td>
</tr>
<tr class="even">
<td><strong>用途</strong></td>
<td>BIOS、固件、引导代码</td>
<td>运行程序、临时数据</td>
<td>操作系统、文件、数据</td>
</tr>
<tr class="odd">
<td><strong>CPU 直接访问</strong></td>
<td>✅ 可以（通过内存映射）</td>
<td>✅ 可以</td>
<td>❌ 不可以（需通过驱动）</td>
</tr>
<tr class="even">
<td><strong>物理位置</strong></td>
<td>主板芯片</td>
<td>内存条插槽</td>
<td>SATA/NVMe 接口</td>
</tr>
</tbody>
</table>
<h3 id="bios-的四大职责">🧱 BIOS 的四大职责</h3>
<h4 id="post">🔍 POST</h4>
<p><strong>加电自检（POST）</strong>：验证 CPU、内存、显卡、键盘等核心器件是否健康。</p>
<table>
<thead>
<tr class="header">
<th>步骤</th>
<th>要做什么</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>检测 CPU</td>
<td>验证寄存器、跑基本指令序列</td>
<td>CPU OK / 错误蜂鸣码</td>
</tr>
<tr class="even">
<td>检测内存</td>
<td>统计容量、快速读写测试、记录可用区域</td>
<td>内存容量 + 可用信息</td>
</tr>
<tr class="odd">
<td>检测显卡</td>
<td>初始化显示适配器、点亮 BIOS 画面</td>
<td>有画面或报显卡故障</td>
</tr>
<tr class="even">
<td>检测其他设备</td>
<td>键盘控制器、磁盘控制器、其他 PCI 设备</td>
<td>可用外设列表</td>
</tr>
</tbody>
</table>
<h4 id="硬件初始化">🛠️ 硬件初始化</h4>
<p><strong>硬件初始化</strong>：配置芯片组、显卡、磁盘控制器，为系统做好底层环境。</p>
<table>
<thead>
<tr class="header">
<th>模块</th>
<th>关键动作</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>芯片组/总线</td>
<td>设置北桥/南桥、PCIe Root Complex、Vcore/Vtt、电源状态</td>
<td>控制器上线，CPU/内存/外设路径打通</td>
</tr>
<tr class="even">
<td>存储控制器</td>
<td>初始化 SATA/NVMe/AHCI、分配 I/O Port/MMIO</td>
<td>磁盘/NVMe 可被扫描、读写</td>
</tr>
<tr class="odd">
<td>显示/外设</td>
<td>启动 GOP/VESA、USB 控制器、风扇曲线、安全策略</td>
<td>BIOS 画面正常显示，输入设备可用</td>
</tr>
<tr class="even">
<td>内存映射</td>
<td>构建 E820、ACPI、SMBIOS 等表的基址与长度</td>
<td>OS 能正确识别硬件拓扑与资源</td>
</tr>
</tbody>
</table>
<h4 id="建立中断向量表">建立中断向量表</h4>
<p>BIOS 在内存最低地址 (<code>0x00000 - 0x003FF</code>) 建立中断向量表(RAM中，因此可修改)：</p>
<p><strong>实模式中断向量表 (IVT) 结构：</strong></p>
<table>
<thead>
<tr class="header">
<th>地址范围</th>
<th>中断向量</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0x0000-0x0003</code></td>
<td>INT 0x00 (除零)</td>
<td>除法错误</td>
</tr>
<tr class="even">
<td><code>0x0004-0x0007</code></td>
<td>INT 0x01 (单步)</td>
<td>调试单步</td>
</tr>
<tr class="odd">
<td><code>0x0008-0x000B</code></td>
<td>INT 0x02 (NMI)</td>
<td>不可屏蔽中断</td>
</tr>
<tr class="even">
<td><code>...</code></td>
<td><code>...</code></td>
<td><code>...</code></td>
</tr>
<tr class="odd">
<td><code>0x0040-0x0043</code></td>
<td>INT 0x10</td>
<td>视频服务 ⭐</td>
</tr>
<tr class="even">
<td><code>0x004C-0x004F</code></td>
<td>INT 0x13</td>
<td>磁盘服务 ⭐</td>
</tr>
<tr class="odd">
<td><code>0x0058-0x005B</code></td>
<td>INT 0x16</td>
<td>键盘服务 ⭐</td>
</tr>
<tr class="even">
<td><code>...</code></td>
<td><code>...</code></td>
<td><code>...</code></td>
</tr>
</tbody>
</table>
<p>每个中断向量占 4 字节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2字节偏移地址] [2字节段地址]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>为什么偏移地址在前？存储格式详解：</strong></p>
<p>这是 <strong>x86 架构的小端序（Little-Endian）</strong> 存储格式。以 INT 0x10 为例（IVT 地址 <code>0x0040</code>）：</p>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0x0040</code></td>
<td><code>IP_low</code></td>
<td>偏移地址低字节（如 <code>0x00</code>）</td>
</tr>
<tr class="even">
<td><code>0x0041</code></td>
<td><code>IP_high</code></td>
<td>偏移地址高字节（如 <code>0x50</code>）</td>
</tr>
<tr class="odd">
<td><code>0x0042</code></td>
<td><code>CS_low</code></td>
<td>段地址低字节（如 <code>0xC0</code>）</td>
</tr>
<tr class="even">
<td><code>0x0043</code></td>
<td><code>CS_high</code></td>
<td>段地址高字节（如 <code>0xF0</code>）</td>
</tr>
</tbody>
</table>
<p><strong>小端序规则</strong>：多字节数据中，<strong>低字节存储在低地址，高字节存储在高地址</strong>。</p>
<ul>
<li>偏移地址 <code>IP = 0x5000</code> → 存储为 <code>[0x00, 0x50]</code>（低字节在前）</li>
<li>段地址 <code>CS = 0xF000</code> → 存储为 <code>[0x00, 0xF0]</code>（低字节在前）</li>
</ul>
<p><strong>为什么 IP 在 CS 之前？</strong></p>
<ul>
<li>这是 x86 实模式的约定：<strong>先存储偏移地址（IP），再存储段地址（CS）</strong>。</li>
<li>CPU 读取时按顺序：先读 IP（2字节），再读 CS（2字节），然后执行 <code>jmp CS:IP</code>。</li>
<li>这种顺序与实模式下的段:偏移寻址方式一致：<code>物理地址 = CS × 16 + IP</code>。</li>
</ul>
</blockquote>
<h4 id="引导加载">🚀 引导加载</h4>
<p><strong>引导加载流程：</strong></p>
<ol type="1">
<li><strong>读取 CMOS 获取启动设备顺序</strong></li>
<li><strong>按顺序尝试每个设备：</strong>
<ul>
<li>软盘驱动器（很少用了）</li>
<li>硬盘（HDD/SSD）</li>
<li>光驱（CD/DVD）</li>
<li>USB 设备</li>
<li>网络启动（PXE）</li>
</ul></li>
<li><strong>读取设备的第 0 扇区（512字节）</strong></li>
<li><strong>检查最后两字节是否为 0x55AA</strong>
<ul>
<li>是 → 这是有效的引导扇区</li>
<li>否 → 尝试下一个设备</li>
</ul>
<blockquote>
<p><strong>为什么是 0x55AA？</strong></p>
<ul>
<li><strong>引导扇区签名</strong>：<code>0x55AA</code> 是 MBR（Master Boot Record）和引导扇区的<strong>魔数（Magic Number）</strong>，位于扇区的最后两个字节（偏移 510-511）。</li>
<li><strong>字节顺序</strong>：由于 x86 是小端序（Little-Endian），<code>0x55AA</code> 在内存中存储为 <code>[0xAA, 0x55]</code>（低字节在前）。</li>
<li><strong>为什么选择这个值？</strong>
<ul>
<li><code>0x55 = 01010101</code>（二进制），<code>0xAA = 10101010</code>（二进制）</li>
<li>这两个字节的<strong>奇偶校验位都是奇数</strong>（1 的个数为奇数），可以用于简单的错误检测。</li>
<li>这个组合在正常数据中出现的概率很低，适合作为"签名"。</li>
</ul></li>
<li><strong>位置</strong>：放在扇区末尾（510-511 字节），确保整个扇区被正确读取后才能验证。</li>
<li><strong>历史</strong>：这是 IBM PC 兼容机规定的标准，所有引导扇区都必须以 <code>0x55AA</code> 结尾，否则 BIOS 不会将其识别为可引导设备。</li>
</ul>
</blockquote></li>
<li><p><strong>将引导扇区加载到内存 0x0000:0x7c00</strong></p>
<blockquote>
<strong><code>0x0000:0x7c00</code> 是什么意思？</strong>
<ul>
<li>这是<strong>实模式下的段:偏移地址表示法</strong>，格式为 <code>段地址:偏移地址</code>。</li>
<li><strong>物理地址计算公式</strong>：<code>物理地址 = 段地址 × 16 + 偏移地址</code></li>
<li><code>0x0000:0x7c00</code> = <code>0x0000 × 16 + 0x7c00</code> = <code>0x00000 + 0x7c00</code> = <strong><code>0x7c00</code></strong>（物理地址）</li>
<li>最终指向物理地址 <code>0x7c00</code>。</li>
<li>实模式下用段:偏移表示，是因为 16 位寄存器只能表示 64KB，通过段地址可以访问更大的地址空间。</li>
</ul>
</blockquote></li>
<li><strong>设置寄存器：</strong>
<ul>
<li><code>CS = 0x0000</code>（代码段寄存器）</li>
<li><code>IP = 0x7c00</code>（指令指针寄存器）</li>
<li><code>DL = 启动设备号 (0x00=软盘, 0x80=硬盘)</code></li>
</ul></li>
<li><p><strong>跳转执行: JMP 0x0000:0x7c00</strong></p></li>
</ol>
<p><strong>为什么是 0x7C00？</strong></p>
<p>这是 IBM PC 5150 (1981年) 规定的地址，选择这个值有以下几个原因：</p>
<ol type="1">
<li><strong>内存布局考虑</strong>
<ul>
<li>引导扇区大小为 512 字节（0x200 字节）。</li>
<li><code>0x7C00</code> 到 <code>0x7DFF</code>（512字节）用于存放引导代码。</li>
<li><code>0x7E00</code> 开始可以用于引导程序的栈空间和数据区。</li>
</ul></li>
<li><strong>与 BIOS 数据区的距离</strong>
<ul>
<li>BIOS 数据区（BDA）位于 <code>0x00400-0x004FF</code>（256字节）。</li>
<li>IVT 位于 <code>0x00000-0x003FF</code>（1KB）。</li>
<li>选择 <code>0x7C00</code> 确保引导代码与这些关键区域有足够距离，避免冲突。</li>
</ul></li>
<li><strong>栈空间预留</strong>
<ul>
<li>实模式下，栈通常向下增长（从高地址向低地址）。</li>
<li><code>0x7C00</code> 以下有足够的空间（约 32KB）可以作为栈使用。</li>
<li>例如：设置 <code>SS:SP = 0x0000:0x7C00</code>，栈可以向下扩展到 <code>0x0000</code>。</li>
</ul></li>
<li><strong>历史约定</strong>
<ul>
<li>IBM PC 5150 的 BIOS 设计者选择了这个值，后续所有兼容机都遵循这个约定。</li>
<li>即使现代系统已经不需要这些限制，为了兼容性仍然使用 <code>0x7C00</code>。</li>
</ul></li>
<li><strong>计算验证</strong>
<ul>
<li><code>0x7C00 = 31744</code> 字节 = 31KB</li>
<li>从 <code>0x00000</code> 到 <code>0x7C00</code> 有 31KB 空间，足够存放 IVT、BDA、视频缓冲区等。</li>
<li>引导扇区加载后，还有约 32KB 空间可用于栈和临时数据。</li>
</ul></li>
</ol>
<p><strong>MBR vs GPT 分区表：</strong></p>
<p>传统 BIOS 主要使用 <strong>MBR（Master Boot Record）</strong> 分区表，而现代 UEFI 系统使用 <strong>GPT（GUID Partition Table）</strong>：</p>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>MBR</th>
<th>GPT</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>全称</strong></td>
<td>Master Boot Record（主引导记录）</td>
<td>GUID Partition Table（GUID 分区表）</td>
</tr>
<tr class="even">
<td><strong>位置</strong></td>
<td>磁盘第一个扇区（512字节）</td>
<td>磁盘开头多个扇区，有主备份</td>
</tr>
<tr class="odd">
<td><strong>分区数量</strong></td>
<td>最多 4 个主分区（或 3 个主分区 + 1 个扩展分区）</td>
<td>理论上无限制（通常支持 128 个分区）</td>
</tr>
<tr class="even">
<td><strong>磁盘容量限制</strong></td>
<td>最大 2TB（由于使用 32 位 LBA）</td>
<td>最大 9.4 ZB（zettabytes，使用 64 位 LBA）</td>
</tr>
<tr class="odd">
<td><strong>分区表备份</strong></td>
<td>无备份，损坏后难以恢复</td>
<td>有主备份和次备份，更安全</td>
</tr>
<tr class="even">
<td><strong>兼容性</strong></td>
<td>所有操作系统都支持</td>
<td>需要 UEFI 或 GPT 兼容的 BIOS</td>
</tr>
<tr class="odd">
<td><strong>引导代码</strong></td>
<td>MBR 包含引导代码（446字节）</td>
<td>GPT 不包含引导代码，由 EFI 系统分区（ESP）处理</td>
</tr>
<tr class="even">
<td><strong>CRC 校验</strong></td>
<td>无</td>
<td>有，可以检测分区表损坏</td>
</tr>
<tr class="odd">
<td><strong>使用场景</strong></td>
<td>传统 BIOS + 小容量磁盘</td>
<td>UEFI + 大容量磁盘（&gt;2TB）</td>
</tr>
</tbody>
</table>
<p><strong>MBR 结构（512字节）：</strong></p>
<ul>
<li><strong>0x000-0x1BD</strong>（446字节）：引导代码</li>
<li><strong>0x1BE-0x1FD</strong>（64字节）：4 个分区表项（每个 16 字节）</li>
<li><strong>0x1FE-0x1FF</strong>（2字节）：引导签名 <code>0x55AA</code></li>
</ul>
<p><strong>GPT 结构：</strong></p>
<ul>
<li><strong>保护性 MBR</strong>：第一个扇区，用于兼容不支持 GPT 的系统</li>
<li><strong>GPT 头</strong>：包含分区表信息</li>
<li><strong>分区表项</strong>：每个分区 128 字节，包含 GUID、名称、起始/结束 LBA 等</li>
<li><strong>备份分区表</strong>：磁盘末尾有完整备份</li>
</ul>
<h3 id="bios-中断服务详解">🔌 BIOS 中断服务详解</h3>
<p><strong>中断是什么？</strong></p>
<p>中断（Interrupt）是 CPU 暂停当前执行流程，转而去处理特定事件或请求的机制。中断分为三类：</p>
<ul>
<li><strong>硬件中断</strong>：由硬件设备触发（如键盘按下、时钟滴答、网卡收到数据包），通过中断控制器（如 8259 PIC）通知 CPU。</li>
<li><strong>软件中断</strong>：由程序主动触发（如 <code>int 0x10</code> 调用 BIOS 视频服务），用于调用系统服务。</li>
<li><strong>异常中断</strong>：由 CPU 内部事件触发（如除零错误、页错误、非法指令），用于错误处理。</li>
</ul>
<p><strong>什么是“中断向量”？</strong></p>
<ul>
<li><strong>中断向量（Interrupt Vector）</strong> 是一个“入口索引”，用于指示某个中断的处理函数地址。</li>
<li>在 BIOS 实模式中，中断向量由 <strong>IVT（Interrupt Vector Table）</strong> 管理：表项编号 0x00~0xFF，对应中断号。</li>
<li><strong>IVT 中存储的是中断处理函数的地址</strong>（实模式的段:偏移）。因此可以理解为：“中断向量”=“中断号对应的处理函数地址”。</li>
<li>CPU 收到中断后，会用中断号（向量）作为索引，在 IVT 中查到处理函数的段地址和偏移地址，然后跳转执行。</li>
</ul>
<p><strong>中断的地址是物理地址还是虚拟地址？</strong></p>
<p>在<strong>实模式下</strong>（BIOS 运行的环境）：</p>
<ul>
<li>中断向量表中的地址是<strong>物理地址</strong>（更准确说是<strong>实模式地址</strong>）。</li>
<li>IVT 位于物理地址 <code>0x00000-0x003FF</code>，每个向量存储的是处理程序的<strong>段地址:偏移地址</strong>（实模式寻址方式）。</li>
<li>CPU 通过 <code>段地址 × 16 + 偏移地址</code> 计算出物理地址，直接访问内存，无需虚拟地址转换。</li>
</ul>
<p>在<strong>保护模式下</strong>（操作系统运行的环境）：</p>
<ul>
<li>使用 <strong>IDT（Interrupt Descriptor Table）</strong> 替代 IVT。</li>
<li>IDT 中的地址可以是<strong>虚拟地址</strong>（如果启用了分页），CPU 会通过页表转换为物理地址。</li>
</ul>
<p>BIOS 提供了一系列中断服务，让引导程序可以使用硬件：</p>
<h4 id="深入理解中断向量表-ivt">💡 深入理解：中断向量表 (IVT)</h4>
<p>在实模式下，BIOS 中断是通过中断向量表（Interrupt Vector Table, IVT）来实现的。</p>
<p><strong>IVT 的结构：</strong></p>
<ul>
<li><strong>地址范围</strong>：<code>0x00000 - 0x003FF</code>（1024 字节 = 1KB）</li>
<li><strong>每个中断向量</strong>：占 4 字节（2 字节偏移地址 + 2 字节段地址）</li>
<li><strong>总向量数</strong>：256 个中断向量（<code>0x00</code> 到 <code>0xFF</code>）</li>
</ul>
<p><strong>内存布局：</strong></p>
<table>
<thead>
<tr class="header">
<th>地址</th>
<th>大小</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0x0000</code></td>
<td>2 字节</td>
<td><code>INT 0x00</code> 偏移地址</td>
</tr>
<tr class="even">
<td><code>0x0002</code></td>
<td>2 字节</td>
<td><code>INT 0x00</code> 段地址</td>
</tr>
<tr class="odd">
<td><code>0x0004</code></td>
<td>2 字节</td>
<td><code>INT 0x01</code> 偏移地址</td>
</tr>
<tr class="even">
<td><code>0x0006</code></td>
<td>2 字节</td>
<td><code>INT 0x01</code> 段地址</td>
</tr>
<tr class="odd">
<td><code>...</code></td>
<td><code>...</code></td>
<td><code>...</code></td>
</tr>
<tr class="even">
<td><code>0x0040</code></td>
<td>2 字节</td>
<td><code>INT 0x10</code> 偏移地址 ⭐</td>
</tr>
<tr class="odd">
<td><code>0x0042</code></td>
<td>2 字节</td>
<td><code>INT 0x10</code> 段地址 ⭐</td>
</tr>
<tr class="even">
<td><code>...</code></td>
<td><code>...</code></td>
<td><code>...</code></td>
</tr>
<tr class="odd">
<td><code>0x03FC</code></td>
<td>2 字节</td>
<td><code>INT 0xFF</code> 偏移地址</td>
</tr>
<tr class="even">
<td><code>0x03FE</code></td>
<td>2 字节</td>
<td><code>INT 0xFF</code> 段地址</td>
</tr>
</tbody>
</table>
<h4 id="中断调用过程">🔄 中断调用过程</h4>
<p>当执行 <code>int 0x10</code> 时，CPU 自动执行以下步骤：</p>
<ol type="1">
<li><p><strong>将 FLAGS 寄存器压栈（保存状态）</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push FLAGS</span><br></pre></td></tr></table></figure></p></li>
<li><strong>CPU 自动清除 IF 标志（禁止中断嵌套）</strong>
<ul>
<li>CPU 自动将 IF 标志设为 0，屏蔽可屏蔽硬件中断。</li>
<li>这相当于自动执行了 <code>cli</code>（Clear Interrupt Flag）指令的效果。</li>
<li>注意：这是 CPU 的<strong>自动行为</strong>，不需要在代码中手动执行 <code>cli</code>。</li>
</ul></li>
<li><strong>CPU 自动清除 TF 标志（禁止单步调试）</strong>
<ul>
<li>CPU 自动将 TF（Trap Flag）标志设为 0，禁用单步调试模式。</li>
<li>这也是 CPU 的<strong>自动行为</strong>，确保中断处理程序不会在调试模式下执行。</li>
</ul></li>
<li><p><strong>将返回地址压栈（CS 和 IP）</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br></pre></td></tr></table></figure></p></li>
<li><strong>从 IVT 读取中断处理程序地址</strong>
<ul>
<li>计算：<code>中断向量地址 = 0x10 × 4 = 0x40</code></li>
<li>读取 IP：<code>读取 [0x40] → IP(偏移)</code></li>
<li>读取 CS：<code>读取 [0x42] → CS(段地址)</code></li>
</ul></li>
<li><p><strong>跳转到中断处理程序</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp CS:IP</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>中断处理程序执行完毕后，执行 <code>iret</code> 返回</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iret: pop IP, pop CS, pop FLAGS</span><br></pre></td></tr></table></figure></p></li>
</ol>
<blockquote>
<p><strong>中断处理程序的栈管理：</strong></p>
<p><strong>栈的使用：</strong></p>
<ul>
<li>当 CPU 执行 <code>int</code> 指令时，会自动将 <strong>FLAGS、CS、IP</strong> 依次压栈（按此顺序）。</li>
<li>栈指针（SP）会<strong>自动减少</strong>（栈向下增长），为这些数据预留空间。</li>
<li>中断处理程序可以使用栈来保存其他寄存器（如 AX、BX 等），但<strong>必须在使用前保存，使用后恢复</strong>。</li>
</ul>
<p><strong>栈布局（进入中断处理程序时）：</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">高地址</span><br><span class="line">[原始 FLAGS]  ← SP（栈顶，最低地址）</span><br><span class="line">[原始 CS]</span><br><span class="line">[原始 IP]     ← 栈底（最高地址）</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure></p>
<p><strong>必须用 <code>iret</code> 返回的原因：</strong></p>
<ul>
<li><code>iret</code> 指令会<strong>按相反顺序</strong>弹出 IP、CS、FLAGS，恢复 CPU 状态。</li>
<li>如果用普通的 <code>ret</code> 返回，只会弹出 IP 和 CS，<strong>不会恢复 FLAGS</strong>，导致中断标志（IF）等状态错误。</li>
<li><code>iret</code> 还会<strong>自动恢复 IF 标志</strong>（如果之前被清除），重新允许硬件中断。</li>
</ul>
<p><strong>寄存器保存约定：</strong></p>
<ul>
<li><strong>必须保存</strong>：如果中断处理程序会修改的寄存器（如 AX、BX、CX、DX、SI、DI、BP、DS、ES 等）。</li>
<li><strong>不需要保存</strong>：FLAGS、CS、IP（CPU 自动保存）。</li>
<li><strong>示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_handler:</span><br><span class="line">    push ax      ; 保存寄存器</span><br><span class="line">    push bx</span><br><span class="line">    ; ... 处理逻辑 ...</span><br><span class="line">    pop bx       ; 恢复寄存器（注意顺序相反）</span><br><span class="line">    pop ax</span><br><span class="line">    iret         ; 必须用 iret 返回</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p><strong>图示说明：</strong></p>
<p>调用：<code>int 0x10</code></p>
<ol type="1">
<li><p><strong>保存现场（栈）</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[FLAGS]  ← SP (栈顶)</span><br><span class="line">[CS]</span><br><span class="line">[IP]</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>计算中断向量地址</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x10 × 4 = 0x40</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>读取 IVT</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x40: IP_low  (偏移地址低字节)</span><br><span class="line">0x41: IP_high (偏移地址高字节)</span><br><span class="line">0x42: CS_low  (段地址低字节)</span><br><span class="line">0x43: CS_high (段地址高字节)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>跳转到 BIOS 代码</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp [读取的CS]:[读取的IP]</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>BIOS 处理并返回</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iret (恢复现场)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="常见中断向量">📋 常见中断向量</h4>
<table>
<thead>
<tr class="header">
<th>中断号</th>
<th>IVT地址</th>
<th>用途</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x00</td>
<td>0x0000</td>
<td>除零错误</td>
<td>CPU异常</td>
</tr>
<tr class="even">
<td>0x01</td>
<td>0x0004</td>
<td>单步调试</td>
<td>CPU调试</td>
</tr>
<tr class="odd">
<td>0x03</td>
<td>0x000C</td>
<td>断点</td>
<td>CPU调试</td>
</tr>
<tr class="even">
<td>0x08</td>
<td>0x0020</td>
<td>时钟中断</td>
<td>硬件IRQ0</td>
</tr>
<tr class="odd">
<td>0x09</td>
<td>0x0024</td>
<td>键盘中断</td>
<td>硬件IRQ1</td>
</tr>
<tr class="even">
<td>0x0E</td>
<td>0x0038</td>
<td>软盘中断</td>
<td>硬件IRQ6</td>
</tr>
<tr class="odd">
<td>0x10</td>
<td>0x0040</td>
<td>视频服务</td>
<td>BIOS服务 ⭐</td>
</tr>
<tr class="even">
<td>0x13</td>
<td>0x004C</td>
<td>磁盘服务</td>
<td>BIOS服务 ⭐</td>
</tr>
<tr class="odd">
<td>0x15</td>
<td>0x0054</td>
<td>系统服务</td>
<td>BIOS服务 ⭐</td>
</tr>
<tr class="even">
<td>0x16</td>
<td>0x0058</td>
<td>键盘服务</td>
<td>BIOS服务 ⭐</td>
</tr>
<tr class="odd">
<td>0x1A</td>
<td>0x0068</td>
<td>时钟服务</td>
<td>BIOS服务</td>
</tr>
<tr class="even">
<td>0x21</td>
<td>0x0084</td>
<td>DOS服务</td>
<td>操作系统(后期)</td>
</tr>
</tbody>
</table>
<h4 id="自定义中断向量示例">💻 自定义中断向量示例</h4>
<p>安装自定义的 INT 0x80 处理程序（类似 Linux 系统调用）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">my_int80_handler:</span><br><span class="line">    ; 处理逻辑</span><br><span class="line">    cmp ah, 0x01</span><br><span class="line">    je print_string    ; 功能1:打印字符串</span><br><span class="line">    ; ...</span><br><span class="line">    iret              ; 必须用iret返回!</span><br><span class="line"></span><br><span class="line">install_handler:</span><br><span class="line">    cli               ; 关闭中断</span><br><span class="line">    ; 计算IVT地址: 0x80 × 4 = 0x200</span><br><span class="line">    xor ax, ax</span><br><span class="line">    mov es, ax        ; ES = 0</span><br><span class="line">    mov bx, 0x0200    ; 偏移 = 0x200</span><br><span class="line">    </span><br><span class="line">    ; 写入偏移地址</span><br><span class="line">    mov word [es:bx], my_int80_handler</span><br><span class="line">    ; 写入段地址</span><br><span class="line">    mov word [es:bx+2], cs</span><br><span class="line">    </span><br><span class="line">    sti               ; 恢复中断</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<h4 id="重要注意事项">⚠️ 重要注意事项</h4>
<ol type="1">
<li><strong>保护模式下 IVT 不可用</strong>
<ul>
<li>进入保护模式后，<strong>IVT 被 IDT（Interrupt Descriptor Table）取代</strong>。</li>
<li>BIOS 中断只能在实模式下使用。</li>
<li>这就是为什么必须在切换到保护模式前完成所有硬件检测和数据读取。</li>
</ul></li>
<li><strong>中断优先级</strong>
<ul>
<li><strong>CPU 异常（0x00-0x1F）</strong>：优先级最高，不可屏蔽。</li>
<li><strong>硬件中断（0x08-0x0F, 0x70-0x77）</strong>：可屏蔽，由 <code>cli</code>/<code>sti</code> 控制。</li>
<li><strong>软件中断（0x20-0xFF）</strong>：通过 <code>int</code> 指令主动触发。</li>
</ul></li>
<li><strong>中断重入问题</strong>
<ul>
<li><code>int</code> 指令会自动清除 IF 标志，防止中断嵌套。</li>
<li>中断处理程序可选择性使用 <code>sti</code> 重新启用中断。</li>
</ul></li>
</ol>
<blockquote>
<p><strong>IF 标志是什么？</strong></p>
<ul>
<li>IF（Interrupt Flag）位于 CPU 的 EFLAGS/FLAGS 寄存器中，用于控制<strong>可屏蔽硬件中断</strong>是否被响应。</li>
<li>IF=1 表示允许 PIC 发送的硬件中断，IF=0 则屏蔽（也就是 <code>cli</code> 指令的效果）。</li>
<li>当执行 <code>int</code> 指令或进入中断处理程序时，CPU 会自动清除 IF=0，避免中断嵌套；处理完毕后通常用 <code>iret</code> 恢复原有 IF 状态，或通过 <code>sti</code> 手动重新开启。</li>
</ul>
</blockquote>
<h3 id="常用-bios-中断服务详解">📺 常用 BIOS 中断服务详解</h3>
<h4 id="int-0x10---视频服务">INT 0x10 - 视频服务</h4>
<p>这是我们在引导程序中最常用的中断之一。</p>
<table>
<thead>
<tr class="header">
<th>AH值</th>
<th>功能</th>
<th>参数</th>
<th>用途示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x00</td>
<td>设置视频模式</td>
<td>AL=模式号</td>
<td>切换文本/图形模式</td>
</tr>
<tr class="even">
<td>0x01</td>
<td>设置光标形状</td>
<td>CX=形状</td>
<td>修改光标外观</td>
</tr>
<tr class="odd">
<td>0x02</td>
<td>设置光标位置</td>
<td>DH=行, DL=列</td>
<td>移动光标</td>
</tr>
<tr class="even">
<td>0x06</td>
<td>滚动窗口</td>
<td>AL=行数</td>
<td>清屏</td>
</tr>
<tr class="odd">
<td>0x0E</td>
<td>显示字符</td>
<td>AL=字符</td>
<td>输出文本 ⭐</td>
</tr>
<tr class="even">
<td>0x13</td>
<td>显示字符串</td>
<td>ES:BP=地址</td>
<td>批量输出</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>什么是 AH？</strong> 在 x86 架构中，CPU 提供了多组通用寄存器（如 AX、BX、CX、DX），每个寄存器 16 位。在实际应用中，这些寄存器还可以细分低 8 位（如 AL、BL）与高 8 位（如 AH、BH）：</p>
<ul>
<li><code>AX</code>：16 位寄存器，可以看作由高 8 位 <code>AH</code> 和低 8 位 <code>AL</code> 组成。</li>
<li><code>AH</code>（“A High”）：AX 的高 8 位，常用于传递功能号或状态（例如 BIOS 中断的功能号一般通过 <code>AH</code> 传递）。</li>
<li><code>AL</code>（“A Low”）：AX 的低 8 位，常用于传递附加参数或数据（如字符等）。</li>
</ul>
</blockquote>
<p><strong>示例：输出 "Hello" 到屏幕</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ah, 0x0E    ; 功能号:Teletype输出</span><br><span class="line">mov al, &#x27;H&#x27;     ; 字符</span><br><span class="line">int 0x10        ; 调用BIOS</span><br><span class="line">;重复输出e, l, l, o</span><br></pre></td></tr></table></figure>
<h4 id="int-0x13---磁盘服务">INT 0x13 - 磁盘服务</h4>
<p>用于读写磁盘扇区：</p>
<table>
<thead>
<tr class="header">
<th>AH值</th>
<th>功能</th>
<th>参数</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x00</td>
<td>复位磁盘</td>
<td>DL=驱动器号</td>
<td>CF=错误标志</td>
</tr>
<tr class="even">
<td>0x02</td>
<td>读扇区 ⭐</td>
<td>AL=扇区数, CH=柱面, CL=扇区, DH=磁头, DL=驱动器, ES:BX=缓冲区</td>
<td>AL=实际读取扇区数</td>
</tr>
<tr class="odd">
<td>0x03</td>
<td>写扇区</td>
<td>同上</td>
<td>AL=实际写入扇区数</td>
</tr>
<tr class="even">
<td>0x08</td>
<td>获取驱动器参数</td>
<td>DL=驱动器</td>
<td>返回几何参数</td>
</tr>
<tr class="odd">
<td>0x41</td>
<td>检测扩展功能</td>
<td>-</td>
<td>是否支持LBA</td>
</tr>
<tr class="even">
<td>0x42</td>
<td>扩展读 (LBA)</td>
<td>DS:SI=参数包</td>
<td>支持大于8GB磁盘</td>
</tr>
</tbody>
</table>
<h4 id="chs-寻址模式">CHS 寻址模式</h4>
<ul>
<li><strong>C (Cylinder)</strong>：柱面号: 0-1023</li>
<li><strong>H (Head)</strong>：磁头号: 0-255</li>
<li><strong>S (Sector)</strong>：扇区号: 1-63（注意：从1开始！）</li>
</ul>
<p><strong>计算公式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理扇区号 = (C × 磁头数 + H) × 每磁道扇区数 + (S - 1)</span><br></pre></td></tr></table></figure>
<h4 id="int-0x16---键盘服务">INT 0x16 - 键盘服务</h4>
<table>
<thead>
<tr class="header">
<th>AH值</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x00</td>
<td>读取按键</td>
<td>AL=ASCII, AH=扫描码</td>
</tr>
<tr class="even">
<td>0x01</td>
<td>检查按键</td>
<td>ZF=1无按键, AL=字符</td>
</tr>
<tr class="odd">
<td>0x02</td>
<td>读取状态</td>
<td>AL=Shift/Ctrl/Alt状态</td>
</tr>
</tbody>
</table>
<h4 id="int-0x15---系统服务">INT 0x15 - 系统服务</h4>
<table>
<thead>
<tr class="header">
<th>AH值</th>
<th>功能</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0xE8, 0x01</td>
<td>获取内存大小</td>
<td>检测系统内存</td>
</tr>
<tr class="even">
<td>0xE8, 0x20</td>
<td>获取内存映射</td>
<td>获取详细内存布局 ⭐</td>
</tr>
<tr class="odd">
<td>0x24, 0x01</td>
<td>启用A20</td>
<td>访问1MB以上内存</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>什么是 A20 地址线？为什么需要启用它？</strong></p>
<p><strong>A20 的历史背景：</strong></p>
<ul>
<li>在早期的 8086/8088 CPU 中，只有 20 根地址线（A0-A19），可以访问 1MB 的地址空间（0x00000-0xFFFFF）。</li>
<li>8086 使用<strong>段:偏移</strong>寻址方式，理论上可以表示 <code>0xFFFF:0xFFFF = 0x10FFEF</code>（约 1MB + 64KB），但由于只有 20 根地址线，超出 1MB 的地址会<strong>回绕</strong>到低地址（例如 <code>0x100000</code> 会回绕到 <code>0x00000</code>）。</li>
<li>这种回绕特性被一些程序利用，作为"内存保护"机制。</li>
</ul>
<p><strong>80286 及以后的问题：</strong></p>
<ul>
<li>80286 引入了 24 根地址线（可访问 16MB），80386 引入了 32 根地址线（可访问 4GB）。</li>
<li>为了保持向后兼容，IBM 在 AT 机型的键盘控制器中增加了一个开关，默认<strong>关闭 A20 地址线</strong>，使系统行为与 8086 一致。</li>
<li>这个开关控制的就是<strong>第 21 根地址线（A20）</strong>，因此被称为 "A20 Gate"。</li>
</ul>
<p><strong>为什么需要启用 A20？</strong></p>
<ul>
<li>要访问 1MB 以上的内存（扩展内存），必须启用 A20 地址线。</li>
<li>现代操作系统和引导程序都需要访问超过 1MB 的内存，因此必须在进入保护模式前启用 A20。</li>
</ul>
<p><strong>启用 A20 的方法：</strong></p>
<ul>
<li>通过键盘控制器（8042）的端口 0x64/0x60</li>
<li>通过 BIOS 中断 INT 0x15, AH=0x24, AL=0x01</li>
<li>通过 Fast A20（直接操作端口 0x92，更快但可能不兼容所有硬件）</li>
</ul>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/181d0004/" rel="prev" title="计算机中的P &#x3D; NP? 问题">
                  <i class="fa fa-angle-left"></i> 计算机中的P = NP? 问题
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/755f751e/" rel="next" title="Clash 与网络代理详解">
                  Clash 与网络代理详解 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa-solid fa-headphones"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">吃糠咽菜</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">217k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:35</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
