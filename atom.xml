<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吃糠咽菜</title>
  
  <subtitle>好记性不如烂笔头</subtitle>
  <link href="https://supermarkli.github.io/atom.xml" rel="self"/>
  
  <link href="https://supermarkli.github.io/"/>
  <updated>2025-10-10T16:25:22.228Z</updated>
  <id>https://supermarkli.github.io/</id>
  
  <author>
    <name>吃糠咽菜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="https://supermarkli.github.io/posts/d87f7e0c/"/>
    <id>https://supermarkli.github.io/posts/d87f7e0c/</id>
    <published>2025-10-10T16:25:10.000Z</published>
    <updated>2025-10-10T16:25:22.228Z</updated>
    
    
      
      
    <summary type="html">&lt;figure&gt;
&lt;img src=&quot;test/image.png&quot; alt=&quot;alt text&quot; /&gt;&lt;figcaption&gt;alt text&lt;/figcaption&gt;
&lt;/figure&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>了解Transformer</title>
    <link href="https://supermarkli.github.io/posts/9008a9df/"/>
    <id>https://supermarkli.github.io/posts/9008a9df/</id>
    <published>2025-10-10T14:53:23.000Z</published>
    <updated>2025-10-10T15:56:29.864Z</updated>
    
    
    <summary type="html">&lt;p&gt;在之前的文章中我们了解到，RNN（及其变体如 LSTM、GRU）在处理序列数据时，必须按照时间步顺序计算，这导致其无法进行大规模并行计算。同时，它也难以解决长距离依赖的问题。&lt;/p&gt;
&lt;p&gt;为了解决这两个核心痛点，一种全新的、不依赖于循环结构的模型——Transformer 横空出世。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>了解RNN</title>
    <link href="https://supermarkli.github.io/posts/da4b49ae/"/>
    <id>https://supermarkli.github.io/posts/da4b49ae/</id>
    <published>2025-10-10T10:44:52.000Z</published>
    <updated>2025-10-10T15:07:50.236Z</updated>
    
    
    <summary type="html">&lt;p&gt;卷积神经网络适合处理图片信息，那文字信息怎么办呢？首先要明白，对于计算机，或者说神经网络来说，文字都是要转换为数字之后再进行处理的。那么我们要面对的第一个问题就是：如何将文字转换为数字？&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>pytorch train 模板</title>
    <link href="https://supermarkli.github.io/posts/14ba9e2c/"/>
    <id>https://supermarkli.github.io/posts/14ba9e2c/</id>
    <published>2025-10-08T03:50:28.000Z</published>
    <updated>2025-10-08T05:36:50.411Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文提供了一个完整、通用的 PyTorch 模型训练流程模板。它涵盖了从数据准备、模型构建、训练循环、测试评估到结果可视化的每一个关键步骤，是快速搭建深度学习项目的实用骨架。</summary>
    
    
    
    <category term="AI" scheme="https://supermarkli.github.io/categories/AI/"/>
    
    <category term="PyTorch" scheme="https://supermarkli.github.io/categories/AI/PyTorch/"/>
    
    
    <category term="PyTorch" scheme="https://supermarkli.github.io/tags/PyTorch/"/>
    
    <category term="深度学习" scheme="https://supermarkli.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="训练模板" scheme="https://supermarkli.github.io/tags/%E8%AE%AD%E7%BB%83%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>pytorch入门</title>
    <link href="https://supermarkli.github.io/posts/5f1831aa/"/>
    <id>https://supermarkli.github.io/posts/5f1831aa/</id>
    <published>2025-10-07T07:24:18.000Z</published>
    <updated>2025-10-07T07:49:51.797Z</updated>
    
    
    <summary type="html">&lt;p&gt;PyTorch 为深度学习提供了强大的数据加载和可视化工具。掌握 &lt;code&gt;Dataset&lt;/code&gt;、&lt;code&gt;DataLoader&lt;/code&gt;、&lt;code&gt;Transforms&lt;/code&gt; 和 &lt;code&gt;TensorBoard&lt;/code&gt; 是高效训练模型的关键。本文将带你快速入门这四大核心组件。</summary>
    
    
    
    <category term="AI" scheme="https://supermarkli.github.io/categories/AI/"/>
    
    <category term="PyTorch" scheme="https://supermarkli.github.io/categories/AI/PyTorch/"/>
    
    
    <category term="PyTorch" scheme="https://supermarkli.github.io/tags/PyTorch/"/>
    
    <category term="深度学习" scheme="https://supermarkli.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CUDA 软件栈</title>
    <link href="https://supermarkli.github.io/posts/dc164fc3/"/>
    <id>https://supermarkli.github.io/posts/dc164fc3/</id>
    <published>2025-09-19T10:36:21.000Z</published>
    <updated>2025-09-24T04:29:00.108Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文尝试用一张图把 CUDA 从“硬件→内核→用户态驱动→工具包→深度学习框架”的完整链路讲清楚，并解释常见的版本不匹配问题与定位思路。即便没有 CUDA 基础，也可以按文中的检查顺序逐步排查。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>eBPF 入门：原理、程序类型与上手实践</title>
    <link href="https://supermarkli.github.io/posts/a9c3e7b1/"/>
    <id>https://supermarkli.github.io/posts/a9c3e7b1/</id>
    <published>2025-09-11T02:29:39.000Z</published>
    <updated>2025-09-11T03:42:41.171Z</updated>
    
    
    <summary type="html">&lt;p&gt;为什么近几年大家都在谈 eBPF？一句话：在不改内核源码的前提下，把“小而安全”的代码段挂到内核关键路径里运行，从而获得接近内核旁路的性能，同时保留 Linux 内核栈的安全与可维护性。&lt;/p&gt;</summary>
    
    
    
    <category term="系统内核" scheme="https://supermarkli.github.io/categories/%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    <category term="计算机网络" scheme="https://supermarkli.github.io/categories/%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Linux" scheme="https://supermarkli.github.io/tags/Linux/"/>
    
    <category term="eBPF" scheme="https://supermarkli.github.io/tags/eBPF/"/>
    
    <category term="网络" scheme="https://supermarkli.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CMake 入门</title>
    <link href="https://supermarkli.github.io/posts/233853f2/"/>
    <id>https://supermarkli.github.io/posts/233853f2/</id>
    <published>2025-09-07T10:51:53.000Z</published>
    <updated>2025-09-08T02:41:21.070Z</updated>
    
    
    <summary type="html">&lt;p&gt;不论你是写 C/C++、CUDA，还是要同时照顾 Linux/Windows/macOS，当项目走出“玩具”阶段，构建就会成为最大的摩擦源：不同编译器、不同 IDE、不同参数、不同依赖的发现与链接。如果还靠手写 &lt;code&gt;Makefile&lt;/code&gt; 或分别维护 VS/Xcode 工程，成本会直线上升。&lt;/p&gt;
&lt;p&gt;这正是 CMake 出现的原因：用一份跨平台的构建脚本，生成各平台各 IDE 需要的工程与命令。</summary>
    
    
    
    <category term="开发工具" scheme="https://supermarkli.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="CMake" scheme="https://supermarkli.github.io/tags/CMake/"/>
    
    <category term="构建系统" scheme="https://supermarkli.github.io/tags/%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="C/C++" scheme="https://supermarkli.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>FaaS（函数即服务）上手指南：从 0 到上云</title>
    <link href="https://supermarkli.github.io/posts/f1a2b3c4/"/>
    <id>https://supermarkli.github.io/posts/f1a2b3c4/</id>
    <published>2025-08-29T06:44:22.000Z</published>
    <updated>2025-08-31T15:48:28.551Z</updated>
    
    
    <summary type="html">&lt;p&gt;这篇文章会带你一起，从 FaaS 的诞生背景聊起，彻底搞懂它的核心概念、真实应用场景，并手把手教你把第一个函数部署上云。&lt;/p&gt;</summary>
    
    
    
    <category term="云原生" scheme="https://supermarkli.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="架构与运维" scheme="https://supermarkli.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Serverless" scheme="https://supermarkli.github.io/tags/Serverless/"/>
    
    <category term="FaaS" scheme="https://supermarkli.github.io/tags/FaaS/"/>
    
    <category term="云原生" scheme="https://supermarkli.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>NVBit 插桩：从 0 到可用</title>
    <link href="https://supermarkli.github.io/posts/d4c3b2a1/"/>
    <id>https://supermarkli.github.io/posts/d4c3b2a1/</id>
    <published>2025-08-14T08:38:13.000Z</published>
    <updated>2025-08-15T06:55:11.827Z</updated>
    
    
    <summary type="html">&lt;p&gt;想在不改用户代码的前提下“看见”每条 GPU 指令如何执行？NVBit 是 NVIDIA 开源的“轻量级 CUDA 指令级动态插桩框架”。本文以“能上手能采样”为目标，从 GPU 并行模型 → CUDA 基础 → PTX/SASS → Linux 注入机制 → NVBit API，总结一份可直接套用的插桩笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="CUDA" scheme="https://supermarkli.github.io/categories/CUDA/"/>
    
    <category term="调试与性能" scheme="https://supermarkli.github.io/categories/CUDA/%E8%B0%83%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="CUDA" scheme="https://supermarkli.github.io/tags/CUDA/"/>
    
    <category term="调试" scheme="https://supermarkli.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="工具" scheme="https://supermarkli.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="NVBit" scheme="https://supermarkli.github.io/tags/NVBit/"/>
    
    <category term="插桩" scheme="https://supermarkli.github.io/tags/%E6%8F%92%E6%A1%A9/"/>
    
  </entry>
  
  <entry>
    <title>Compute Sanitizer 实用指南：从 0 到熟练</title>
    <link href="https://supermarkli.github.io/posts/a1b2c3d4/"/>
    <id>https://supermarkli.github.io/posts/a1b2c3d4/</id>
    <published>2025-08-14T08:23:58.000Z</published>
    <updated>2025-08-15T06:53:38.095Z</updated>
    
    
    <summary type="html">&lt;p&gt;想把 CUDA 程序里的“越界读写、未初始化、数据竞争、Barrier 不匹配”这类顽固 Bug 一网打尽？Compute Sanitizer（前身 &lt;code&gt;cuda-memcheck&lt;/code&gt;）就是你的第一生产力工具。本文以“能上手能排错”为目标，按难度循序渐进，从最小示例、常见报错，到命令参数与协同工具给出一份“即插即用”的参考。&lt;/p&gt;</summary>
    
    
    
    <category term="CUDA" scheme="https://supermarkli.github.io/categories/CUDA/"/>
    
    <category term="调试与性能" scheme="https://supermarkli.github.io/categories/CUDA/%E8%B0%83%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="CUDA" scheme="https://supermarkli.github.io/tags/CUDA/"/>
    
    <category term="GPU" scheme="https://supermarkli.github.io/tags/GPU/"/>
    
    <category term="调试" scheme="https://supermarkli.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="工具" scheme="https://supermarkli.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Tensor 基础：布局、算子与形状推导</title>
    <link href="https://supermarkli.github.io/posts/f1e2d3c4/"/>
    <id>https://supermarkli.github.io/posts/f1e2d3c4/</id>
    <published>2025-08-13T13:00:00.000Z</published>
    <updated>2025-09-09T07:19:50.005Z</updated>
    
    
    <summary type="html">&lt;p&gt;想看懂卷积、池化公式却老被 &lt;code&gt;NCHW&lt;/code&gt;、&lt;code&gt;stride&lt;/code&gt; 搞糊涂？本文聚焦 &lt;strong&gt;张量布局 → 常见算子 → 形状计算公式&lt;/strong&gt;，用一篇梳理基础概念。&lt;/p&gt;</summary>
    
    
    
    <category term="深度学习" scheme="https://supermarkli.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="计算机基础" scheme="https://supermarkli.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="深度学习" scheme="https://supermarkli.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="张量" scheme="https://supermarkli.github.io/tags/%E5%BC%A0%E9%87%8F/"/>
    
    <category term="形状推导" scheme="https://supermarkli.github.io/tags/%E5%BD%A2%E7%8A%B6%E6%8E%A8%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>Python 语法与工程骨架</title>
    <link href="https://supermarkli.github.io/posts/6a8247a7/"/>
    <id>https://supermarkli.github.io/posts/6a8247a7/</id>
    <published>2025-08-13T06:42:41.000Z</published>
    <updated>2025-08-13T07:05:32.638Z</updated>
    
    
    <summary type="html">&lt;p&gt;想在大型项目里写出“既优雅又不掉坑”的 Python？本文用 &lt;strong&gt;抽象基类 → 生成器 → 类型提示 → 模块组织&lt;/strong&gt; 四步，给你一套可复用的工程骨架。</summary>
    
    
    
    <category term="软件开发" scheme="https://supermarkli.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="Python" scheme="https://supermarkli.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
    
    <category term="Python" scheme="https://supermarkli.github.io/tags/Python/"/>
    
    <category term="工程实践" scheme="https://supermarkli.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>CUDA核心概念与内存层次</title>
    <link href="https://supermarkli.github.io/posts/d4b8f045/"/>
    <id>https://supermarkli.github.io/posts/d4b8f045/</id>
    <published>2025-08-13T04:11:31.000Z</published>
    <updated>2025-08-13T06:10:56.415Z</updated>
    
    
    <summary type="html">&lt;p&gt;想在一张图看懂 GPU 的线程组织与内存层次？本文用表格 + Mermaid 图 + 代码示例，3 分钟带你摸清 Kernel、Warp、合并访存与 bank 冲突的底层逻辑。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>H100 服务器 CUDA + PyTorch 环境速配指南</title>
    <link href="https://supermarkli.github.io/posts/e5b1c8d2/"/>
    <id>https://supermarkli.github.io/posts/e5b1c8d2/</id>
    <published>2025-08-11T09:20:08.000Z</published>
    <updated>2025-08-11T09:37:54.995Z</updated>
    
    
    <summary type="html">&lt;p&gt;想在全新的 Ubuntu-24.04 + H100 机器上“第一天就跑通 GPU 代码”？&lt;/p&gt;</summary>
    
    
    
    <category term="深度学习" scheme="https://supermarkli.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="环境配置" scheme="https://supermarkli.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="CUDA" scheme="https://supermarkli.github.io/tags/CUDA/"/>
    
    <category term="PyTorch" scheme="https://supermarkli.github.io/tags/PyTorch/"/>
    
    <category term="H100" scheme="https://supermarkli.github.io/tags/H100/"/>
    
    <category term="GPU" scheme="https://supermarkli.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>GPU 工作原理：和 CPU 有何不同？</title>
    <link href="https://supermarkli.github.io/posts/d1a2c3b4/"/>
    <id>https://supermarkli.github.io/posts/d1a2c3b4/</id>
    <published>2025-08-10T09:38:06.000Z</published>
    <updated>2025-08-11T02:52:42.294Z</updated>
    
    
    <summary type="html">&lt;p&gt;如果把 CPU 比作“多才多艺的总管”，GPU 更像“高效的流水线工厂”：CPU 擅长复杂分支与少量任务的低延迟处理，GPU 擅长大量相同/相似任务的高吞吐处理。本文先给出关键概念，再用 CPU 对比串起 GPU 的架构、执行模型、内存层次与性能要点。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://supermarkli.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="硬件体系结构" scheme="https://supermarkli.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%A1%AC%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="GPU" scheme="https://supermarkli.github.io/tags/GPU/"/>
    
    <category term="CPU" scheme="https://supermarkli.github.io/tags/CPU/"/>
    
    <category term="并行计算" scheme="https://supermarkli.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="计算机基础" scheme="https://supermarkli.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux 包管理：从入门到进阶的实战指南</title>
    <link href="https://supermarkli.github.io/posts/3b71e21f/"/>
    <id>https://supermarkli.github.io/posts/3b71e21f/</id>
    <published>2025-08-08T08:19:11.000Z</published>
    <updated>2025-08-08T09:02:15.070Z</updated>
    
    
    <summary type="html">&lt;p&gt;如果把发行版比作操作系统的“应用商店”，包管理器就是开发与运维最常用的“装、删、查、管”工具。本文从概念到实操、从单机到团队，给出一份可以落地的学习大纲与命令速查，帮助你跨发行版高效工作。&lt;/p&gt;</summary>
    
    
    
    <category term="技术工具" scheme="https://supermarkli.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Linux" scheme="https://supermarkli.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/Linux/"/>
    
    
    <category term="Linux" scheme="https://supermarkli.github.io/tags/Linux/"/>
    
    <category term="包管理" scheme="https://supermarkli.github.io/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
    <category term="Package" scheme="https://supermarkli.github.io/tags/Package/"/>
    
  </entry>
  
  <entry>
    <title>开源许可证速查：MIT、Apache 2.0、GPL v3 怎么选？</title>
    <link href="https://supermarkli.github.io/posts/c3f2a1b9/"/>
    <id>https://supermarkli.github.io/posts/c3f2a1b9/</id>
    <published>2025-08-08T07:14:41.000Z</published>
    <updated>2025-08-08T07:18:00.387Z</updated>
    
    
    <summary type="html">&lt;p&gt;面对五花八门的开源许可证，最常被问到的无非三件事：能不能商用？能不能改了闭源？要不要写专利和修改声明？这篇文章用一张速查表和几条决策准则，帮你在 1 分钟内选对证。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://supermarkli.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="开源" scheme="https://supermarkli.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%BC%80%E6%BA%90/"/>
    
    
    <category term="开源" scheme="https://supermarkli.github.io/tags/%E5%BC%80%E6%BA%90/"/>
    
    <category term="License" scheme="https://supermarkli.github.io/tags/License/"/>
    
    <category term="许可证" scheme="https://supermarkli.github.io/tags/%E8%AE%B8%E5%8F%AF%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>混合加密入门：集安全与效率于一身的艺术</title>
    <link href="https://supermarkli.github.io/posts/8c9a7e4f/"/>
    <id>https://supermarkli.github.io/posts/8c9a7e4f/</id>
    <published>2025-08-08T02:00:00.000Z</published>
    <updated>2025-08-06T08:49:33.102Z</updated>
    
    
    <summary type="html">&lt;p&gt;在数字世界中，我们渴望两全其美：既想要信息传输绝对安全，又追求其过程畅快高效。若把数据加密比作锁门，我们面临一个两难选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对称加密&lt;/strong&gt;像一把普通的房门钥匙：开锁和上锁都用同一把，速度飞快，但把这把唯一的钥匙安全地交给远方的朋友却成了一个大难题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非对称加密&lt;/strong&gt;则像一个银行保险箱：对外提供一个只能存东西的“公钥”（存款口），而取东西的“私钥”（保险箱钥匙）则由自己牢牢保管。它完美解决了密钥分发问题，但操作起来却相对“笨重”，处理大量数据时效率不高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有没有一种方法，能让我们同时拥有对称加密的“快”和非对称加密的“稳”呢？答案是肯定的，这就是我们今天要探讨的主角——&lt;strong&gt;混合加密 (Hybrid Encryption)&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://supermarkli.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="安全" scheme="https://supermarkli.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="加密" scheme="https://supermarkli.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
    <category term="密码学" scheme="https://supermarkli.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="安全" scheme="https://supermarkli.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>git之路：rebase &amp; cherry-pick</title>
    <link href="https://supermarkli.github.io/posts/1566a5aa/"/>
    <id>https://supermarkli.github.io/posts/1566a5aa/</id>
    <published>2025-08-05T10:01:30.000Z</published>
    <updated>2025-08-06T09:36:29.397Z</updated>
    
    
    <summary type="html">&lt;p&gt;在团队协作和日常开发中，&lt;code&gt;rebase&lt;/code&gt; 和 &lt;code&gt;cherry-pick&lt;/code&gt; 是 Git 中非常强大的两个命令。它们不仅能让你的提交历史更加清晰，还能灵活地“搬运”代码。本文结合一张可视化分支图，带你深入理解这两者的用法与区别，并掌握团队协作中的最佳实践。&lt;/p&gt;</summary>
    
    
    
    <category term="技术工具" scheme="https://supermarkli.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Git" scheme="https://supermarkli.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/Git/"/>
    
    
    <category term="Git" scheme="https://supermarkli.github.io/tags/Git/"/>
    
    <category term="Rebase" scheme="https://supermarkli.github.io/tags/Rebase/"/>
    
    <category term="Cherry-pick" scheme="https://supermarkli.github.io/tags/Cherry-pick/"/>
    
  </entry>
  
</feed>
