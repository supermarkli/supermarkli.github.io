<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吃糠咽菜</title>
  
  <subtitle>好记性不如烂笔头</subtitle>
  <link href="https://supermarkli.github.io/atom.xml" rel="self"/>
  
  <link href="https://supermarkli.github.io/"/>
  <updated>2025-11-21T05:14:06.577Z</updated>
  <id>https://supermarkli.github.io/</id>
  
  <author>
    <name>吃糠咽菜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BIOS</title>
    <link href="https://supermarkli.github.io/posts/ea91aa61/"/>
    <id>https://supermarkli.github.io/posts/ea91aa61/</id>
    <published>2025-11-19T09:09:15.000Z</published>
    <updated>2025-11-21T05:14:06.577Z</updated>
    
    
    <summary type="html">&lt;p&gt;想快速看懂“上电到操作系统启动”这段黑屏时间到底发生了什么？&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机中的P = NP? 问题</title>
    <link href="https://supermarkli.github.io/posts/181d0004/"/>
    <id>https://supermarkli.github.io/posts/181d0004/</id>
    <published>2025-10-26T08:49:26.000Z</published>
    <updated>2025-10-26T09:09:51.139Z</updated>
    
    
    <summary type="html">&lt;p&gt;在计算机科学领域，有一个悬赏一百万美元的世纪难题，它就是“P=NP?”问题。这个问题非常重要，它关系到计算机的算力极限，也和我们生活中的很多问题（如密码学、物流规划、人工智能等）息息相关。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>了解Diffusion Language Model</title>
    <link href="https://supermarkli.github.io/posts/a1d79e4c/"/>
    <id>https://supermarkli.github.io/posts/a1d79e4c/</id>
    <published>2025-10-25T03:02:35.000Z</published>
    <updated>2025-10-25T03:56:28.526Z</updated>
    
    
    <summary type="html">&lt;p&gt;我们熟悉的 Transformer 等模型采用“自回归”方式逐词生成文本，这限制了生成速度且不易保证长文本连贯。受图像生成领域成功的 &lt;strong&gt;扩散模型 (Diffusion Model)&lt;/strong&gt; 启发，研究者将其引入文本生成，&lt;strong&gt;扩散语言模型 (Diffusion Language Model)&lt;/strong&gt; 应运而生。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>内网穿透与远程桌面：用 Tailscale 随时随地访问你的 Windows</title>
    <link href="https://supermarkli.github.io/posts/8a7b3c2d/"/>
    <id>https://supermarkli.github.io/posts/8a7b3c2d/</id>
    <published>2025-10-16T04:42:21.000Z</published>
    <updated>2025-10-16T05:56:44.400Z</updated>
    
    
    <summary type="html">&lt;p&gt;是否曾想在咖啡馆、酒店或任何有网络的地方，像坐在自己书房一样操作家里的电脑？无论是访问重要文件、运行特定软件，还是进行远程维护，直接访问一台不在身边的计算机都是一个常见的需求。&lt;/p&gt;
&lt;p&gt;传统方法（如公网 IP + 端口转发）配置复杂且有安全风险。本文将介绍一种极其简单且安全的组合方案：&lt;strong&gt;Tailscale + Windows 远程桌面&lt;/strong&gt;，让你轻松实现稳定、高效的远程访问。&lt;/p&gt;</summary>
    
    
    
    <category term="技术工具" scheme="https://supermarkli.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/"/>
    
    <category term="系统运维" scheme="https://supermarkli.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Windows" scheme="https://supermarkli.github.io/tags/Windows/"/>
    
    <category term="内网穿透" scheme="https://supermarkli.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    <category term="远程桌面" scheme="https://supermarkli.github.io/tags/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/"/>
    
    <category term="Tailscale" scheme="https://supermarkli.github.io/tags/Tailscale/"/>
    
    <category term="网络基础" scheme="https://supermarkli.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>大模型百词</title>
    <link href="https://supermarkli.github.io/posts/8c9ab17b/"/>
    <id>https://supermarkli.github.io/posts/8c9ab17b/</id>
    <published>2025-10-10T17:04:38.000Z</published>
    <updated>2025-10-10T17:15:10.176Z</updated>
    
    
    <summary type="html">&lt;p&gt;当下，大模型（Large Model）无疑是科技领域最炙手可热的话题。从 ChatGPT 的惊艳亮相到各类 AIGC 应用的层出不穷，我们每天都会接触到海量的新名词和新概念。为了帮助大家更好地理解这个日新月异的领域，本文梳理了一系列核心术语，希望能为你构建一个清晰的知识地图。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>了解Transformer</title>
    <link href="https://supermarkli.github.io/posts/9008a9df/"/>
    <id>https://supermarkli.github.io/posts/9008a9df/</id>
    <published>2025-10-10T14:53:23.000Z</published>
    <updated>2025-10-10T17:05:31.888Z</updated>
    
    
    <summary type="html">&lt;p&gt;在之前的文章中我们了解到，RNN（及其变体如 LSTM、GRU）在处理序列数据时，必须按照时间步顺序计算，这导致其无法进行大规模并行计算。同时，它也难以解决长距离依赖的问题。&lt;/p&gt;
&lt;p&gt;为了解决这两个核心痛点，一种全新的、不依赖于循环结构的模型——Transformer 横空出世。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>了解RNN</title>
    <link href="https://supermarkli.github.io/posts/da4b49ae/"/>
    <id>https://supermarkli.github.io/posts/da4b49ae/</id>
    <published>2025-10-10T10:44:52.000Z</published>
    <updated>2025-10-10T15:07:50.236Z</updated>
    
    
    <summary type="html">&lt;p&gt;卷积神经网络适合处理图片信息，那文字信息怎么办呢？首先要明白，对于计算机，或者说神经网络来说，文字都是要转换为数字之后再进行处理的。那么我们要面对的第一个问题就是：如何将文字转换为数字？&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>pytorch train 模板</title>
    <link href="https://supermarkli.github.io/posts/14ba9e2c/"/>
    <id>https://supermarkli.github.io/posts/14ba9e2c/</id>
    <published>2025-10-08T03:50:28.000Z</published>
    <updated>2025-10-08T05:36:50.411Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文提供了一个完整、通用的 PyTorch 模型训练流程模板。它涵盖了从数据准备、模型构建、训练循环、测试评估到结果可视化的每一个关键步骤，是快速搭建深度学习项目的实用骨架。</summary>
    
    
    
    <category term="AI" scheme="https://supermarkli.github.io/categories/AI/"/>
    
    <category term="PyTorch" scheme="https://supermarkli.github.io/categories/AI/PyTorch/"/>
    
    
    <category term="PyTorch" scheme="https://supermarkli.github.io/tags/PyTorch/"/>
    
    <category term="深度学习" scheme="https://supermarkli.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="训练模板" scheme="https://supermarkli.github.io/tags/%E8%AE%AD%E7%BB%83%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>pytorch入门</title>
    <link href="https://supermarkli.github.io/posts/5f1831aa/"/>
    <id>https://supermarkli.github.io/posts/5f1831aa/</id>
    <published>2025-10-07T07:24:18.000Z</published>
    <updated>2025-10-10T16:45:22.824Z</updated>
    
    
    <summary type="html">&lt;p&gt;PyTorch 为深度学习提供了强大的数据加载和可视化工具。掌握 &lt;code&gt;Dataset&lt;/code&gt;、&lt;code&gt;DataLoader&lt;/code&gt;、&lt;code&gt;Transforms&lt;/code&gt; 和 &lt;code&gt;TensorBoard&lt;/code&gt; 是高效训练模型的关键。本文将带你快速入门这四大核心组件。</summary>
    
    
    
    <category term="AI" scheme="https://supermarkli.github.io/categories/AI/"/>
    
    <category term="PyTorch" scheme="https://supermarkli.github.io/categories/AI/PyTorch/"/>
    
    
    <category term="PyTorch" scheme="https://supermarkli.github.io/tags/PyTorch/"/>
    
    <category term="深度学习" scheme="https://supermarkli.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CUDA 软件栈</title>
    <link href="https://supermarkli.github.io/posts/dc164fc3/"/>
    <id>https://supermarkli.github.io/posts/dc164fc3/</id>
    <published>2025-09-19T10:36:21.000Z</published>
    <updated>2025-09-24T04:29:00.108Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文尝试用一张图把 CUDA 从“硬件→内核→用户态驱动→工具包→深度学习框架”的完整链路讲清楚，并解释常见的版本不匹配问题与定位思路。即便没有 CUDA 基础，也可以按文中的检查顺序逐步排查。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>eBPF 入门：原理、程序类型与上手实践</title>
    <link href="https://supermarkli.github.io/posts/a9c3e7b1/"/>
    <id>https://supermarkli.github.io/posts/a9c3e7b1/</id>
    <published>2025-09-11T02:29:39.000Z</published>
    <updated>2025-09-11T03:42:41.171Z</updated>
    
    
    <summary type="html">&lt;p&gt;为什么近几年大家都在谈 eBPF？一句话：在不改内核源码的前提下，把“小而安全”的代码段挂到内核关键路径里运行，从而获得接近内核旁路的性能，同时保留 Linux 内核栈的安全与可维护性。&lt;/p&gt;</summary>
    
    
    
    <category term="系统内核" scheme="https://supermarkli.github.io/categories/%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/"/>
    
    <category term="计算机网络" scheme="https://supermarkli.github.io/categories/%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Linux" scheme="https://supermarkli.github.io/tags/Linux/"/>
    
    <category term="eBPF" scheme="https://supermarkli.github.io/tags/eBPF/"/>
    
    <category term="网络" scheme="https://supermarkli.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CMake 入门</title>
    <link href="https://supermarkli.github.io/posts/233853f2/"/>
    <id>https://supermarkli.github.io/posts/233853f2/</id>
    <published>2025-09-07T10:51:53.000Z</published>
    <updated>2025-09-08T02:41:21.070Z</updated>
    
    
    <summary type="html">&lt;p&gt;不论你是写 C/C++、CUDA，还是要同时照顾 Linux/Windows/macOS，当项目走出“玩具”阶段，构建就会成为最大的摩擦源：不同编译器、不同 IDE、不同参数、不同依赖的发现与链接。如果还靠手写 &lt;code&gt;Makefile&lt;/code&gt; 或分别维护 VS/Xcode 工程，成本会直线上升。&lt;/p&gt;
&lt;p&gt;这正是 CMake 出现的原因：用一份跨平台的构建脚本，生成各平台各 IDE 需要的工程与命令。</summary>
    
    
    
    <category term="开发工具" scheme="https://supermarkli.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="CMake" scheme="https://supermarkli.github.io/tags/CMake/"/>
    
    <category term="构建系统" scheme="https://supermarkli.github.io/tags/%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="C/C++" scheme="https://supermarkli.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>FaaS（函数即服务）上手指南：从 0 到上云</title>
    <link href="https://supermarkli.github.io/posts/f1a2b3c4/"/>
    <id>https://supermarkli.github.io/posts/f1a2b3c4/</id>
    <published>2025-08-29T06:44:22.000Z</published>
    <updated>2025-08-31T15:48:28.551Z</updated>
    
    
    <summary type="html">&lt;p&gt;这篇文章会带你一起，从 FaaS 的诞生背景聊起，彻底搞懂它的核心概念、真实应用场景，并手把手教你把第一个函数部署上云。&lt;/p&gt;</summary>
    
    
    
    <category term="云原生" scheme="https://supermarkli.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="架构与运维" scheme="https://supermarkli.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Serverless" scheme="https://supermarkli.github.io/tags/Serverless/"/>
    
    <category term="FaaS" scheme="https://supermarkli.github.io/tags/FaaS/"/>
    
    <category term="云原生" scheme="https://supermarkli.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>NVBit 插桩：从 0 到可用</title>
    <link href="https://supermarkli.github.io/posts/d4c3b2a1/"/>
    <id>https://supermarkli.github.io/posts/d4c3b2a1/</id>
    <published>2025-08-14T08:38:13.000Z</published>
    <updated>2025-08-15T06:55:11.827Z</updated>
    
    
    <summary type="html">&lt;p&gt;想在不改用户代码的前提下“看见”每条 GPU 指令如何执行？NVBit 是 NVIDIA 开源的“轻量级 CUDA 指令级动态插桩框架”。本文以“能上手能采样”为目标，从 GPU 并行模型 → CUDA 基础 → PTX/SASS → Linux 注入机制 → NVBit API，总结一份可直接套用的插桩笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="CUDA" scheme="https://supermarkli.github.io/categories/CUDA/"/>
    
    <category term="调试与性能" scheme="https://supermarkli.github.io/categories/CUDA/%E8%B0%83%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="CUDA" scheme="https://supermarkli.github.io/tags/CUDA/"/>
    
    <category term="调试" scheme="https://supermarkli.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="工具" scheme="https://supermarkli.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="NVBit" scheme="https://supermarkli.github.io/tags/NVBit/"/>
    
    <category term="插桩" scheme="https://supermarkli.github.io/tags/%E6%8F%92%E6%A1%A9/"/>
    
  </entry>
  
  <entry>
    <title>Compute Sanitizer 实用指南：从 0 到熟练</title>
    <link href="https://supermarkli.github.io/posts/a1b2c3d4/"/>
    <id>https://supermarkli.github.io/posts/a1b2c3d4/</id>
    <published>2025-08-14T08:23:58.000Z</published>
    <updated>2025-08-15T06:53:38.095Z</updated>
    
    
    <summary type="html">&lt;p&gt;想把 CUDA 程序里的“越界读写、未初始化、数据竞争、Barrier 不匹配”这类顽固 Bug 一网打尽？Compute Sanitizer（前身 &lt;code&gt;cuda-memcheck&lt;/code&gt;）就是你的第一生产力工具。本文以“能上手能排错”为目标，按难度循序渐进，从最小示例、常见报错，到命令参数与协同工具给出一份“即插即用”的参考。&lt;/p&gt;</summary>
    
    
    
    <category term="CUDA" scheme="https://supermarkli.github.io/categories/CUDA/"/>
    
    <category term="调试与性能" scheme="https://supermarkli.github.io/categories/CUDA/%E8%B0%83%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="CUDA" scheme="https://supermarkli.github.io/tags/CUDA/"/>
    
    <category term="GPU" scheme="https://supermarkli.github.io/tags/GPU/"/>
    
    <category term="调试" scheme="https://supermarkli.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="工具" scheme="https://supermarkli.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Tensor 基础：布局、算子与形状推导</title>
    <link href="https://supermarkli.github.io/posts/f1e2d3c4/"/>
    <id>https://supermarkli.github.io/posts/f1e2d3c4/</id>
    <published>2025-08-13T13:00:00.000Z</published>
    <updated>2025-09-09T07:19:50.005Z</updated>
    
    
    <summary type="html">&lt;p&gt;想看懂卷积、池化公式却老被 &lt;code&gt;NCHW&lt;/code&gt;、&lt;code&gt;stride&lt;/code&gt; 搞糊涂？本文聚焦 &lt;strong&gt;张量布局 → 常见算子 → 形状计算公式&lt;/strong&gt;，用一篇梳理基础概念。&lt;/p&gt;</summary>
    
    
    
    <category term="深度学习" scheme="https://supermarkli.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="计算机基础" scheme="https://supermarkli.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="深度学习" scheme="https://supermarkli.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="张量" scheme="https://supermarkli.github.io/tags/%E5%BC%A0%E9%87%8F/"/>
    
    <category term="形状推导" scheme="https://supermarkli.github.io/tags/%E5%BD%A2%E7%8A%B6%E6%8E%A8%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>Python 语法与工程骨架</title>
    <link href="https://supermarkli.github.io/posts/6a8247a7/"/>
    <id>https://supermarkli.github.io/posts/6a8247a7/</id>
    <published>2025-08-13T06:42:41.000Z</published>
    <updated>2025-08-13T07:05:32.638Z</updated>
    
    
    <summary type="html">&lt;p&gt;想在大型项目里写出“既优雅又不掉坑”的 Python？本文用 &lt;strong&gt;抽象基类 → 生成器 → 类型提示 → 模块组织&lt;/strong&gt; 四步，给你一套可复用的工程骨架。</summary>
    
    
    
    <category term="软件开发" scheme="https://supermarkli.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="Python" scheme="https://supermarkli.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/Python/"/>
    
    
    <category term="Python" scheme="https://supermarkli.github.io/tags/Python/"/>
    
    <category term="工程实践" scheme="https://supermarkli.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>CUDA核心概念与内存层次</title>
    <link href="https://supermarkli.github.io/posts/d4b8f045/"/>
    <id>https://supermarkli.github.io/posts/d4b8f045/</id>
    <published>2025-08-13T04:11:31.000Z</published>
    <updated>2025-08-13T06:10:56.415Z</updated>
    
    
    <summary type="html">&lt;p&gt;想在一张图看懂 GPU 的线程组织与内存层次？本文用表格 + Mermaid 图 + 代码示例，3 分钟带你摸清 Kernel、Warp、合并访存与 bank 冲突的底层逻辑。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>H100 服务器 CUDA + PyTorch 环境速配指南</title>
    <link href="https://supermarkli.github.io/posts/e5b1c8d2/"/>
    <id>https://supermarkli.github.io/posts/e5b1c8d2/</id>
    <published>2025-08-11T09:20:08.000Z</published>
    <updated>2025-08-11T09:37:54.995Z</updated>
    
    
    <summary type="html">&lt;p&gt;想在全新的 Ubuntu-24.04 + H100 机器上“第一天就跑通 GPU 代码”？&lt;/p&gt;</summary>
    
    
    
    <category term="深度学习" scheme="https://supermarkli.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="环境配置" scheme="https://supermarkli.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="CUDA" scheme="https://supermarkli.github.io/tags/CUDA/"/>
    
    <category term="PyTorch" scheme="https://supermarkli.github.io/tags/PyTorch/"/>
    
    <category term="H100" scheme="https://supermarkli.github.io/tags/H100/"/>
    
    <category term="GPU" scheme="https://supermarkli.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>GPU 工作原理：和 CPU 有何不同？</title>
    <link href="https://supermarkli.github.io/posts/d1a2c3b4/"/>
    <id>https://supermarkli.github.io/posts/d1a2c3b4/</id>
    <published>2025-08-10T09:38:06.000Z</published>
    <updated>2025-08-11T02:52:42.294Z</updated>
    
    
    <summary type="html">&lt;p&gt;如果把 CPU 比作“多才多艺的总管”，GPU 更像“高效的流水线工厂”：CPU 擅长复杂分支与少量任务的低延迟处理，GPU 擅长大量相同/相似任务的高吞吐处理。本文先给出关键概念，再用 CPU 对比串起 GPU 的架构、执行模型、内存层次与性能要点。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://supermarkli.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="硬件体系结构" scheme="https://supermarkli.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%A1%AC%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="GPU" scheme="https://supermarkli.github.io/tags/GPU/"/>
    
    <category term="CPU" scheme="https://supermarkli.github.io/tags/CPU/"/>
    
    <category term="并行计算" scheme="https://supermarkli.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
    
    <category term="计算机基础" scheme="https://supermarkli.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
